## DIT172 | Report on Project-1 | itp22104 | .../12/2023

### Γενικά

#### _Αντικειμενοστραφής Σχεδιασμός/Υλοποίηση_
Ορίζουμε την κλάση `Person` που αντιπροσωπεύει κάθε ένα από τα άτομα που συμμετέχουν στην ανταλλαγή μηνυμάτων.
Η κλάση έχει μεθόδους που αντιστοιχούν στα βήματα της διαδικασίας ανταλλαγής μηνυμάτων τα οποία θα πραγματοποιήσει η μία ή άλλη πλευρά.

#### _Χρήση Βιβλιοθήκης_
Ο κώδικας χρησιμοποιεί τη βιβλιοθήκη κρυπτογραφίας [PyNaCl](https://pynacl.readthedocs.io/en/latest/) και ειδικότερα κλάσεις/μεθόδους όπως οι `PrivateKey, Box, SecretBox, blake2b` για τη δημιουργία κλειδιών, την κρυπτογράφηση/αποκρυπτογράφηση, έλεγχο ακεραιότητας κλπ.

### Ειδικότερα

#### Σχεδιασμός: `Person` class

Αναπαριστά την εκάστοτε πλευρά η οποία συμμετέχει στη διαδικασία και ορίζει attributes τα οποία κρατούν τις απαιτούμενες πληροφορίες για τις ενέργειες που θα πραγματοποιήσει οι οποίες υλοποιούνται από τις  μεθόδους της.

Συγκεκριμένα:

- _Attributes_
    - `self.name` &rarr; Το όνομα της εκάστοτε πλευράς
    - `self.private` &rarr; Το ιδιωτικό κλειδί της εκάστοτε πλευράς
    - `self.public, self.other_public` &rarr; Το δημόσιο κλειδί της μιας και της άλλης πλευράς
    - `self.common_secret` &rarr; Το κοινό μυστικό $\mathrm{K}$
    - `self.derived_key` &rarr; Το παραγόμενο από την $\mathrm{KDF}$ κλειδί $\mathrm{K}^{'}$
    - `self.encrypted_message` &rarr; Το κρυπτογραφημένο μήνυμα
    - `self.message` &rarr; Το αρχικό προς ανταλαγή μήνυμα
    - `self.tag, self.other_tag` &rarr; Η ετικέτα της μιας και της άλλης πλευράς
- _Methods_
    - `get_other_public()`  
    Αποθηκεύει στο instance της `Person` το δημόσιο κλειδί της άλλης πλευράς
    - `make_key_pair()`  
    Δημιουργεί και αποθηκεύει στο instance της `Person` ένα ζεύγος δημοσίου/ιδιωτικού κλειδιού με χρήση της `PrivateKey` της `PyNaCl`.  
    [Χρησιμοποιείται ο αλγόριθμός _Curve25519_](https://pynacl.readthedocs.io/en/latest/public/#nacl.public.PrivateKey) που παρέχει επίπεδο ασφάλειας 128 bits και [το σχήμα ελλειπτικής καμπύλης Diffie–Hellman](https://en.wikipedia.org/wiki/Curve25519)
    - `make_common_secret()`  
    Χρησιμοποιεί το ιδιωτικό κλειδί του instance της `Person` και το δημόδιο κλειδί της άλλης πλευράς για να παράξει και αποθηκεύσει το κοινό μυστικό $\mathrm{K}$ στο instance της `Person`.  
    Γϊνεται χρήση της [`Box`](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-box) της `PyNaCl`
    - `make_derived_key()`  
    Με χρήση της _key derivation function_ [`blake2b`](https://pynacl.readthedocs.io/en/latest/hashing/#key-derivation) και είσοδο το κοινό μυστικό $\mathrm{K}$ παράγεται αποθηκεύεται στο instance της `Person` το κλειδί $\mathrm{K}^{'}$ το οποίο γίνεται truncated σε 32 χαρακτήρες λόγω του απαιτούμενου μεγέθους εισόδου στην κλάση κρυπτογράφησης `SecretBox` (βλ. `encrypt_message()`)
    - `make_message()`  
    Παράγεται το μήνυμα προς ανταλλαγή
    - `encrypt_message()`  
    Χρησιμοποιεί το κλειδί $\mathrm{K}^{'}$ του instance της `Person` για να κρυπτογραφήσει και να αποθηκεύσει στο instance το μήνυμα που παράχθηκε.  
    Γίνεται χρήση της κλάσης `SecretBox` της `PyNaCl` η οποία δέχεται ως είσοδο κλειδί 32 bytes και για την κρυπτογράφηση χρησιμοποιεί τον αλγόριθμο _XSalsa20 stream cipher_ ([1](https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xsalsa20), [2](https://en.wikipedia.org/wiki/Salsa20#XSalsa20_with_192-bit_nonce)). Η κλάση [εισάγει κι έναν αυθεντικοποιητή των 16 byte](https://pynacl.readthedocs.io/en/latest/secret/#reference) με τον αλγόριθμο [Poly1305 MAC](https://en.wikipedia.org/wiki/Poly1305), ο οποίος ελέγχεται κατά την αποκρυπτογράφηση.
    - `make_tag()`  
    Δημιουργεί και αποθηκεύει την ετικέτα από το κρυπτογραφημένο μήνυμα για το instance της `Person` για τη διαδικασία ελέγχου ακεραιότητας με χρήση της [`blake2b`](https://pynacl.readthedocs.io/en/latest/hashing/#integrity-check-examples)
    - `get_requirements()`  
    Δέχεται ως είσοδο και αποθηκεύει τις πληροφορίες που χρειάζονται στο instance της `Person` που έχει το ρόλο του παραλήπτη για την αποκρυπτογράφηση και τον έλεγχο ακεραιότητας το μηνύματος
    - `verify_integrity()`  
    Πραγματοποιεί τον έλεγχο ακεραιότητας του μηνύματος από τη μεριά του παραλήπτη. Χρησιμοποιεί τη συνάρτηση [`sodium_memcmp`](https://pynacl.readthedocs.io/en/latest/hashing/#integrity-check-examples) της `PyNaCl` και τυπώνει το αντίστοιχο μήνυμα κατά τον έλεγχο τερματίζοντας το πρόγραμμα σε περίπτωση αποτυχίας
    - `decrypt_message()`  
    Χρησιμοποιεί την κλάση `SecretBox` της `PyNaCl` η οποία αρχικοποιείται με το παραγόμενο κλειδί $\mathrm{K}^{'}$ του instance της `Person` και τη μέθοδό της `decrypt()` που δέχεται ως είσοδο το κρυπτογραφημένο μήνυμα για να κάνει την αποκρυπτογράφηση και τυπώνει το αντίστοιχο μήνυμα κατά τον έλεγχο τερματίζοντας το πρόγραμμα σε περίπτωση αποτυχίας

#### Υλοποίηση: Βήματα

1. Αρχικοποίηση της `Person` για τον _Bob_
2. Δημιουργία κλειδιών για τον _Bob_ με την `make_key_pair()`
3. Αρχικοποίηση της `Person` για την _Alice_
4. Η _Alice_ λαμβάνει το δημόσιο κλειδί του _Bob_ με την `get_other_public()`
5. Δημιουργία κλειδιών για την _Alice_ με την `make_key_pair()`
6. Η _Alice_ δημιουργεί το κοινό μυστικό $\mathrm{K}$ με την `make_common_secret()`
7. Η _Alice_ δημιουργεί το παραγόμενο κλειδί $\mathrm{K}^{'}$ με την `make_derived_key()`
8. Η _Alice_ δημιουργεί το μήνυμα με την `make_message()`
9. Η _Alice_ κρυπτογραφεί το μήνυμα με την `encrypt_message()`
10. Η _Alice_ δημιουργεί την ετικέτα ακεραιότητας με την `make_tag()`
11. Ο _Bob_ λαμβάνει τις απαραίτητες πληροφορίες για αποκρυπτογράφηση/έλεγχο ακεραιότητας με την `get_requirements()`
12. Ο _Bob_ δημιουργεί το κοινό μυστικό $\mathrm{K}$ από το ιδιωτικό κλειδί του και το δημόδιο κλειδί της _Alice_ με την `make_common_secret()`
13. Ο _Bob_ δημιουργεί το παραγόμενο κλειδί $\mathrm{K}^{'}$ με την `make_derived_key()`
14. Ο _Bob_ κάνει έλεγχο ακεραιότητας με την `verify_integrity()` όπου τυπώνεται το αντίστοιχο μύνημα και σε περίπτωση αποτυχίας τερματίζεται το πρόγραμμα
15. Ο _Bob_ κάνει αποκρυπτογράφηση με την `decrypt_message()` όπου τυπώνεται το αντίστοιχο μύνημα και σε περίπτωση αποτυχίας τερματίζεται το πρόγραμμα

Μπορούμε να ελέγξουμε την αποτυχία του προγράμματος αλλάζοντας το κρυπτογραφημέννο μήνυμα ή την ετικέτα της _Alice_ πριν το βήμα 11.